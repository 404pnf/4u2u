<?php

/* $Id: ffmpeg_wrapper.module,v 1.1.2.20.2.31 2009/11/11 17:54:22 arthuregg Exp $ */

// This implements a wrapper for FFmpeg so that we don't have to reinvent the
// the wheel every time we want to do something with video, audio, or images


/* ************************************************ */
/* DRUPAL HOOKS */
/* ************************************************ */

/**
 * Implementation of hook_menu().
 */
function ffmpeg_wrapper_menu() {
  $items = array();
  $items['admin/settings/ffmpeg_wrapper'] = array(
    'title' => 'FFmpeg Wrapper',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ffmpeg_wrapper_admin'),
    'access arguments' => array('administer ffmpeg wrapper'),
  );
  $items[] = array(
    'path' => 'admin/settings/ffmpeg_wrapper/default',
    'title' => 'FFmpeg Wrapper',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // hand back the specific configurations for a codec
  $items['ffmpeg_wrapper/output'] = array(
    'title' => 'FFmpeg Wrapper',
    'page callback' => 'ffmpeg_wrapper_output_display',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  // testing utilities
  $items['admin/settings/ffmpeg_wrapper/test'] = array(
    'title' => t('FFmpeg Wrapper Test Conversion'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ffmpeg_wrapper_ffmpeg_test_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer ffmpeg wrapper'),
    'file' => 'ffmpeg_wrapper_test_convert.inc',
  );
  $items['admin/settings/ffmpeg_wrapper/test_cleanup'] = array(
    'title' => 'FFmpeg Wrapper Test Cleanup',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ffmpeg_wrapper_test_cleanup_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer ffmpeg wrapper'),
    'file' => 'ffmpeg_wrapper_test_convert.inc',
  );

  // hand back the specific configurations for a codec
  $items['ffmpeg_wrapper/file_data'] = array(
    'title' => 'FFmpeg Wrapper',
    'page callback' => 'ffmpeg_wrapper_file_type_ahah',
    'access arguments' => array('administer ffmpeg wrapper'),
    'file' => 'ffmpeg_wrapper_test_convert.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}


/**
 * Implementation of hook_perm().
 */
function ffmpeg_wrapper_perm() {
  return array('administer ffmpeg wrapper');
}


/**
 * add a link to do conversion testing on the standard file display
 * checks to make sure the file is usable by ffmpeg
 *
 * @param string $form_id
 * @param array $form
 */
function ffmpeg_wrapper_form_alter(&$form, $form_state, $form_id) {
  // if user does not have rights to test with ffmpeg
  if (! user_access('administer ffmpeg wrapper')) {
    return;
  }

  // Are there attached files?
  if (isset($form['attachments']) && $files = $form['attachments']['wrapper']['files']) {
    foreach ($files as $fid => $file) {
      // check to make sure this is a file array and if this file is decodeable by ffmpeg
      // we are dealing with a form element, so we have to make sure that this is the part that we want
      if (is_array($file)) {
        // can ffmpeg decode this?
        if (ffmpeg_wrapper_can_decode($file['filepath']['#value'])) {
          $arguments = array();
          // are we on a node page? Add a $nid to the arguments
          if ($nid = $form['#node']->nid) { $arguments[] = "nid=$nid"; }
          // we need a path to the file to the arguments
          $arguments[] = 'path='. $file['filepath']['#value'];
           // create the link for test conversion
          $link = '<br />'. l(t('Test convert file with FFmpeg'), 'admin/settings/ffmpeg_wrapper/test', array('query' => implode('&', $arguments)));
          // now we alter the description of this item
          $form['attachments']['wrapper']['files'][$fid]['description']['#description'] .= $link;
        }
      }
    }
  }
}


/**
 * Implementation of Drupal 6's theme registry
 * @return array
 */
function ffmpeg_wrapper_theme() {
  return array(
    'ffmpeg_wrapper_files_checkboxes' => array(
      'arguments' => array('form' => NULL),
    ),
    'ffmpeg_wrapper_files_radios' => array(
      'arguments' => array('form' => NULL),
    ),
  );
}


/* ************************************************ */
/* FFmpeg Wrapper Admin Functions                   */
/* ************************************************ */

/**
 * Build the admin form.
 */
function ffmpeg_wrapper_admin() {
  // always clear caches when if settings are updated
  cache_clear_all('ffmpeg_wrapper_codecs', 'cache');
  cache_clear_all('ffmpeg_wrapper_output_formats', 'cache');
  cache_clear_all('ffmpeg_wrapper_file_formats', 'cache');

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('FFmpeg'),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg'),
    '#description' => t('Absolute path to the FFmpeg exeutable. Leave blank if you do not need this.'),
  );

  $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhook'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to the FFmpeg vhook libraries'),
    '#default_value' => variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook'),
    '#description' => t('Absolute path to the FFmpeg vhook directory. No trailing slash. Leave blank if you do not need this'),
  );

  // configuration options
  // only display if we can reach the binary
  if (ffmpeg_wrapper_run_command()) {
    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about'] = array(
      '#type' => 'fieldset',
      '#title' => t('About FFmpeg installation'),
      '#collapsible' => true,
      '#collapsed' => true,
    );

    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about']['ffmpeg_wrapper_version'] = array(
      '#type' => 'item',
      '#title' => t('FFmpeg version'),
      '#value' =>  '<blockquote>'. ffmpeg_wrapper_run_command('-v') .'</blockquote>',
      '#description' => t('Version of FFmpeg running on your system'),
    );

    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about']['ffmpeg_wrapper_formats'] = array(
      '#type' => 'item',
      '#title' => t('Supported file formats'),
      '#value' =>  ffmpeg_wrapper_formats_data_display(),
      '#description' => t('File formats that the installed version of FFmpeg supports.'),
    );

    $form['ffmpeg_wrapper']['ffmpeg_wrapper_about']['ffmpeg_wrapper_codecs'] = array(
      '#type' => 'item',
      '#title' => t('Installed codecs'),
      '#value' => ffmpeg_wrapper_get_codecs_display(),
      '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
    );
  }

  // get a list of the vhooks in the system
  if (ffmpeg_wrapper_vhook_list()) {
    $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhooks'] = array(
      '#type' => 'fieldset',
      '#title' => t('vhook files installed on this system'),
      '#collapsible' => true,
      '#collapsed' => true,
    );
    $form['ffmpeg_wrapper']['ffmpeg_wrapper_vhooks']['ffmpeg_wrapper_vhook'] = array(
      '#type' => 'item',
      '#title' => t('vhook files'),
      '#value' =>  implode('<br />', ffmpeg_wrapper_vhook_list()),
      '#description' => t('List of all the Vhook files found.'),
    );
  }
  return system_settings_form($form);
}


/**
 * validate the options on the ffmpeg form
 *
 * @param int $form_id
 * @param array $form_values
 */
function ffmpeg_wrapper_admin_validate($form, &$form_state) {
  // make sure we've got the path to the ffmpeg binary
  if (! ffmpeg_wrapper_run_command(null, false, $form_state['values']['ffmpeg_wrapper_path']) && $form_values['ffmpeg_wrapper_path']) {
    form_set_error('ffmpeg_wrapper_path', t('FFmpeg binary was not found on the path you specified. Maybe try a different path?'));
  }

  // check and see if we can find the vhook directory
  if (! is_dir($form_state['values']['ffmpeg_wrapper_vhook']) && $form_state['values']['ffmpeg_wrapper_vhook']) {
    form_set_error('ffmpeg_wrapper_vhook', t('The vhook directory was not found on the path you specified. Maybe try a different path?'));
  }
}


/* ************************************************ */
/* Interactions with ffmpeg                         */
/* ************************************************ */

/**
 * Get data from ffmpeg.
 *
 * @param $command
 *   The options to run ffmpeg with.
 * @param $error_check
 *   If TRUE, runs error checking on the output.
 * @param $path
 *   Overrides the system settings.
 * @param $ffmpeg_object
 *   Object for passing debug and other kinds of data through the system.
 * @return
 *   Output of the command.
 */
function ffmpeg_wrapper_run_command($command = '', $error_check = true, $path = '', &$ffmpeg_object = null) {
  // override the system path?
  if (! $path) {
    $path = variable_get('ffmpeg_wrapper_path', '/usr/bin/ffmpeg');
  }
  if (empty($ffmpeg_object)) {
    $ffmpeg_object = new stdClass();
  }
  
  // Create some exceptions for dealing with pipes and semicolons
  $pattern = array('\;', '\|');
  $replace = array(';', '|');
  
  // Escape our command, but make sure that we allow | and ;
  $ffmpeg_object->command = str_replace($pattern, $replace, escapeshellcmd($path .' '. $command));
  
  $ffmpeg_object->cwd = getcwd();

  // does binary exist?
  if (! file_exists($path)) {
    return false;
  }

  // run the command
  ob_start();
    passthru($ffmpeg_object->command." 2>&1", $command_return);
    $ffmpeg_object->output = ob_get_contents();
  ob_end_clean();

  // Find the output file in the command if there was one.
  // This is sort of hacky but is helpful for passing the file out.
  preg_match("/.*'(.*)'$/i", $command, $matches);
  $ffmpeg_object->output_file = !empty($matches[1]) ? $matches[1] : null;

  // do error handling if requested
  if ($error_check) {
    if (! ffmpeg_wrapper_error_check($ffmpeg_object, true)){
      return false;
    }
  }
  return $ffmpeg_object->output;
}


/**
 * builds a list of the ffmpeg vhook options installed on this machine
 * @TODO we need to get more information on how the vhook system works and how
 *       admins can utilize it
 *
 * @param string $path
 * @return array
 */
function ffmpeg_wrapper_vhook_list($path = '') {
  static $files;

  // if we have a list already
  if ($files) {
     return $files;
  }

  // build the path
  if (! $path) {
    $path = variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook');
  }

  // @TODO replace below with file_scan_directory($path);

  // check to see if the directory is correct
  if (is_dir($path)) {
    // open the directory
    if ($dir = opendir($path)) {
      while (($file = readdir($dir)) !== false) {
        // do not this or parrent directory
        if ($file != "." && $file != "..") {
          $files[] = $path .'/'. $file;
        }
      }
      closedir($dir);
    }
    if (count($files)) {
      return $files;
    }
  }
}


/**
 * Check an incoming file to see if it can be decoded by comparing the file's codec
 * and format against the list of decode formats in FFMPEG.
 *
 * @param $file
 *   string, A full system filepath.
 * @param $types
 *   array, what kind of decode do we need to check for
 * @return
 *   boolean, TRUE if file is in the list of decodeable files.
 */
function ffmpeg_wrapper_can_decode($path, $types = array('video', 'audio')) {
  // get the kind of files
  $file_types = ffmpeg_wrapper_get_file_formats('decode');

  // get the format and codec information on this file
  $file_data = ffmpeg_wrapper_file_data($path);

   // if the file has multiple formats, all formats
   // must be in $file_types Otherwise, it is
   // not supported by ffmpeg.
  foreach(explode(',', $file_data['format']) as $type) {
    if (! in_array($type, $file_types)) {
      return false;
    }
  }

  // if we have na values for the audio and video codecs, the file can not be decoded
  // @ TODO is this really true? The logic below does not seem to indicate this,
  //        however, I might not understand what the 'na' value really means
  if ($file_data['audio']['codec'] == 'na' && $file_data['video']['codec'] == 'na') {
    return false;
  }

  // Now get installed codecs to compare file codecs
  foreach (ffmpeg_wrapper_get_codecs('decode') as $codec) {
    if ($codec == $file_data['audio']['codec'] || $file_data['audio']['codec'] == 'na' ) {
       // are we only handing back audio?
      if ($types['audio'] && ! $types['video']) { return true; }
      $can_audio_decode = true;
    }

    if ($codec == $file_data['video']['codec'] || $file_data['video']['codec'] == 'na') {
      // are we only handing back video?
      if ($types['video'] && ! $types['audio']) { return true; }
      $can_video_decode = true;
    }

    // If we can decode both audio and video, the file is ok
    if ($can_audio_decode && $can_video_decode) {
      return true;
    }
  }
  return false;
}


/**
 * Get an array of codec types usable on this system.
 * This should probably be smoothed out so that it doesn't rely on text so
 * much.
 * Caches data to avoid extra command line hits.
 *
 * @ TODO this needs to be rethought to pass params right
 *
 * @param $return
 *   Determins hand back of encode/decode.
 * @return
 *   Array of codecs or specific encode/decode options.
 */
function ffmpeg_wrapper_get_codecs($return = 'rows') {
  $cache_id = 'ffmpeg_wrapper_codecs';
  $cache = cache_get($cache_id, 'cache');
  if (!isset($cache->data)) {
    $data = array();
    // get formats from ffmpeg
    //$output = ffmpeg_wrapper_run_command('-formats');
		$output = ffmpeg_wrapper_run_command('-codecs');

    // parse the list
    // we know where the codecs are by looking at the output of ffmpeg -formats
    $codecs_formats_pos = strpos($output, "Codecs:");
    $codecs_formats_pos_end = strpos($output, "Supported file protocols:");
    $codecs = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));
    // remove the extra text
    $codecs = str_replace('Codecs:', '', $codecs);
    // convert to array
    $codecs = explode("\n", $codecs);

    $rows = array();
    foreach ($codecs as $codec) {
      // match the decode, encode, type, S|D|T options (see: http://lists.mplayerhq.hu/pipermail/ffmpeg-user/2006-January/002003.html)
      // name
      $pattern ='/[ ]*([D ])([E ])([ VA])([S ])([ D])([ T])[ ]*([a-zA-Z0-9_,]*)[ ]*([a-zA-Z0-9,_ ]*)/';
      preg_match($pattern, $codec, $matches);

      // codec names
      $a_format['name'] = $matches[7];

      // get the codec type
      if ($matches[3] == 'A') {
        $a_format['type'] = t('audio');
        $encode_formats[] = $a_format['name'];
      }
      else {
        $a_format['type'] = t('video');
      }

      // get the decode value
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        $decode_formats[] = $a_format['name'];
      }
      else {
        $a_format['decode'] = t('no');
      }

      // get the encode value
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        $encode_formats[] = $a_format['name'];
      }
      else {
        $a_format['encode'] = t('no');
      }

      if ($a_format['name']) {
        $rows[] = $a_format;
      }
      $a_format = null;
    }
    $data['encode'] = $encode_formats;
    $data['decode'] = $decode_formats;
    $data['rows'] = $rows;
    cache_set($cache_id, $data, 'cache', CACHE_TEMPORARY);
  }
  else {
    $data = $cache->data;
  }

  return $data[$return];
}


/**
 * Get a list of codecs in key value form- for use in form display
 *
 * @param $type
 *   audio or video.
 * @return
 *   Array of codec names.
 */
function ffmpeg_wrapper_return_codecs($type) {
  static $codecs;
  if (! empty($codecs[$type])) {
    return $codecs[$type];
  }
  $codecs = array();
  $codecs[$type] = array(0 => t('Use default'));
  // get list of avaiable audio and video codecs
  $codec_list = ffmpeg_wrapper_get_codecs();
  if ($codec_list) {
    foreach ($codec_list as $codec) {
      if ($codec['encode'] == "yes" && $codec['type'] == $type) {
        $codecs[$type][$codec['name']] = $codec['name'];
      }
    }
  }
  return $codecs[$type];
}


/**
 * Helper function to build the list of output formats on the system.
 * Data is cached to reduce hits to ffmpeg.
 *
 * @return
 *   Array of key values
 */
function ffmpeg_wrapper_output_formats() {
  $cache_id = 'ffmpeg_wrapper_output_formats';
  $cache = cache_get($cache_id, 'cache');
  if (!isset($cache->data)) {
    // get all the encoding options
    $outputs = ffmpeg_wrapper_get_file_formats('encode');
    // rebuild as a select array
    $formats = array(t('Select output type'));
    foreach ($outputs as $output) {
      $formats[$output] = $output;
    }
    cache_set($cache_id, $formats, 'cache', CACHE_TEMPORARY);
  }
  else {
    $formats = $cache->data;
  }
  return $formats;
}


/**
 * Build the output rates for each type of bit rate that ffmpeg offers.
 *
 * @param $type
 *   Type of bit rate: "ab", "ar", "fps" or "br".
 * @return
 *   Array of key values.
 */
function ffmpeg_wrapper_output_rates($type) {
  static $rates;
  if (! $rates) {
    $rates = array(
     'ab'  => array('16k' => '16k', '22k' => '22k', '32k' => '32k', '64k' => t('64k (default)'), '128k' => '128k', '192k' => '192k', '256k' => '256k'),
     'ar' => array('11025' => t('11khz'), '22050' => t('22khz'), '32000' => t('32khz'), '44100' => t('44.1khz (default)') ),
     'fps' => array(10 => 10, 15 => 15, 20 => 20, 25 => t('25 (default)'), 29.97 => 29.97),
     'br' => array('50k' => t('50kps'), '100k' => t('100kps'), '150k' => t('150kps'), '200k' => t('200kps'), '250k' => t('250kps (default)'), '300k' => t('300kps'), '500k' => t('500kps'), '750k' => t('750kps'), '1000k' => t('1000kps'), '1250k' => t('1250kps'), '1500k' => t('1500kps'), '2000k' => t('2000kps')),
    );
  }
  return $rates[$type];
}


/**
* Output dimentions form settings.
* @return
*   An array of frame sizes.
*/
function ffmpeg_wrapper_frame_sizes(){
  $frame_sizes = array(
    '0' => t('No alteration'),
    '128x96' => '128x96',
    '176x144' => '176x144',
    '320x240' => '320x240',
    '352x288' => '352x288',
    '512x386' => '512x386',
    '704x576' => '704x576'
  );
  $frame_sizes['other'] = t('Other');
  return $frame_sizes;
}


/**
 * Get an array of format types usable on this system.
 * This should probably be smoothed out so that it doesn't rely on text so
 * much. If no value for $ret is given, return the descriptions. This data
 * is all built by scanning the output from ffmpeg.
 *
 * @param $ret
 *   Determins what to hand back (encode/decode).
 * @return
 *   Array of options.
 */
function ffmpeg_wrapper_get_file_formats($ret = 'row') {
  $cache_id = 'ffmpeg_wrapper_file_formats';
  $cache = cache_get($cache_id, 'cache');
  // do we have cached data?
  if (!isset($cache->data)) {
    // if we can't get formats, do not bother
    if (! $formats = ffmpeg_wrapper_run_command('-formats') ) {
      return;
    }
    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');
    $formats = substr($formats, $startpos, $endpos - $startpos);
    //remove the header
    $formats = str_replace('File formats:', '', $formats);

    $decode_formats = array();
    $encode_formats = array();

    $rows = array();

    foreach (explode("\n", $formats) as $format) {
      // match the decode, encode, format, description
      $pattern ='/[ ]*([D ])([E ])[ ]*([a-zA-Z0-9_,]*)[ ]*([^\$]*)/';
      preg_match($pattern, $format, $matches);

      $a_format['type'] = $matches[3];
      $a_format['name'] = $matches[4];

      // check for decoding
      if ($matches[1] == 'D') {
        $a_format['decode'] = t('yes');
        // we can have multiple types per format
        $types = explode(',', $a_format['type']);
        foreach ($types as $type) {
          $decode_formats[] = $type;
        }
      }
      else {
        $a_format['decode'] = t('no');
      }

      // check for encoding
      if ($matches[2] == 'E') {
        $a_format['encode'] = t('yes');
        // we can have multiple types per format
        $types = explode(',', $a_format['type']);
        foreach ($types as $type) {
          $encode_formats[] = $type;
        }
      }
      else {
        $a_format['encode'] = t('no');
      }

      $a_format['description'] = $matches[4];
      if ($a_format['description']) {
        $rows[] = $a_format;
      }
    }

    $output = array();
    $output['encode'] = $encode_formats;
    $output['decode'] = $decode_formats;
    $output['row'] = $rows;

    cache_set($cache_id, $output, 'cache', CACHE_TEMPORARY);
  }
  else {
    $output = $cache->data;
  }
  // return the requested data
  return $output[$ret];
}


/**
 * Get the duration of a video.
 *
 * @param $path
 *   The path to file.
 * @param $timecode
 *   If TRUE, return time code, otherwise return seconds.
 * @param $output
 *   string, output of ffmpeg if it has already been run
 * @return
 *   Duration in seconds as an integer or timecode as string.
 */
function ffmpeg_wrapper_file_duration($path, $timecode = null, $output = null) {
  // do we have any output from ffmpeg already?
  if (! $output) {
    // get duration from ffmpeg
    // need quotes around the path parameter in case filename has spaces.
    $output = ffmpeg_wrapper_run_command("-i \"$path\"");
  }

  // parse the output looking for "Duration: 00:02:12"
  $pattern = "/Duration: ([0-9]+:[0-9]+:[0-9]+)\.[0-9]+/";
  preg_match($pattern, $output, $matches);

  $time = $matches[1];

  if (! $timecode) {
    // now we need to convert the time code to seconds
    // get the time into an array
    $time = explode(':', $time);

    $seconds = 0;
    if ($time[0] != '00') {
      $seconds += $time[0] * 60 * 60;
    }
    if ($time[1] != '00') {
      $seconds += $time[1] * 60;
    }
    $seconds += $time[2];
    $time = $seconds;
  }
  return $time;
}


/**
 * This function produces file data from an incoming file
 * @param $path
 * @param $timecode
 * @return array
 */
function ffmpeg_wrapper_file_data($path = null) {
  if (file_exists($path)) {
    // get duration from ffmpeg
    // need quotes around the path parameter in case filename has spaces.
    $output = ffmpeg_wrapper_run_command("-i \"$path\"");

    // get file format
    $pattern = '/Input #0, (.*),/';
    preg_match($pattern, $output, $matches);
    $file['format'] = !empty($matches[1]) ? $matches[1] : 'na';

    // get file duration
    $file['duration'] = ffmpeg_wrapper_file_duration(null, null, $output);

    // get bit rate
    $pattern = "/bitrate: ([0-9].*\/s)/";
    preg_match($pattern, $output, $matches);
    $file['bitrate'] = !empty($matches[1]) ? $matches[1] : 'na';

    // get audio settings
    // format is: codec, sample rate, stereo/mono, bitrate
    $pattern = "/Audio: (.*), ([0-9]*) Hz, (stereo|mono)/";
    preg_match($pattern, $output, $matches);
    $file['audio']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
    $file['audio']['ar'] = !empty($matches[2]) ? $matches[2] : 'na';
    $file['audio']['ac'] = (!empty($matches[3]) && $matches[3] == 'stereo') ? 2 : 1;

    // take the last match and extract the bit rate if present
    $pattern = "/Audio: .* (.*) kb\/s/";
    preg_match($pattern, $output, $matches);
    $file['audio']['ab'] = !empty($matches[1]) ? $matches[1] : 'na';

    // VIDEO ----------------------------------------
    // The formating of video can be difficult. We use 3 different
    // patterns to look for the video information

    // try pattern that takes into account a codec's color space (example: yuv420p)
    // eg: Video: mpeg1video, yuv420p, 320x240 [PAR 1:1 DAR 4:3], 990 kb/s, 30.00 tb(r)
    // the above is: codec, color space, frame size, bitrate, frame rate
    $pattern1 = "/Video: ([^,]+), ([^,]+), ([0-9x]+)[^,]*, ([0-9]*.*\/s|[A-Za-z]+[^,]*), ([0-9\.]*)/";

    // pattern that omits video bitrate but not color space.
    // eg: Video: mpeg4, yuv420p, 640x480 [PAR 1:1 DAR 4:3], 23.98 tb(r)
    // the above is: codec, color space, frame size, frame rate
    $pattern2 = "/Video: ([^,]+), ([^0-9][^,]*), ([0-9x]+)[^,]*, ([0-9\.]*)/";

    // pattern that omits a codec's color space and video bitrate
    // eg: Video: mpeg4, 640x480, 29.97 tb(r)
    // the above is: codec, frame size, frame rate
    $pattern3 = "/Video: ([^,]+), ([0-9x]+)[^,]*, ([0-9\.]*)/";

    // did we find the video information on the first try ?
    if (preg_match($pattern1, $output, $matches)) {
      $file['video']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
      // $file['video']['type'] = $matches[2];
      $file['video']['s'] = !empty($matches[3]) ? $matches[3] : 'na';
      $file['video']['br'] = !empty($matches[4]) ? $matches[4] : 'na';
    }
    elseif (preg_match($pattern2, $output, $matches)) {
      $file['video']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
      $file['video']['s'] = !empty($matches[3]) ? $matches[3] : 'na';
      $file['video']['br'] = 'na';
    }
    elseif (preg_match($pattern3, $output, $matches)) {
      $file['video']['codec'] = !empty($matches[1]) ? $matches[1] : 'na';
      $file['video']['s'] = !empty($matches[3]) ? $matches[3] : 'na';
      $file['video']['br'] = 'na';
    }
    return $file;
  }
}


/**
 * Calculate an output size and a padding value for a video file.
 *
 * @param $file
 *   Path to the file to be converted.
 * @param $size
 *   The maximum dimensions of the output file, expressed as XXXxYYY. This will
 *   be cropped to match the original file's proportions and the remaining
 *   space will be used to calculate the padding.
 * @param $return
 *   Either 'padding' or 'size'.
 * @return
 *   Depending on the value of $return, the function returns either the size
 *   expressed as XXXxYYY, or the actual padding argument for FFmpeg, ie.
 *   "-padtop XX -padbottom XX". The result is statically cached, so you can
 *   call it multiple times without permormance issues.
 */
function ffmpeg_wrapper_padded_size($file, $size, $return = 'padding') {
  static $file_proportions;

  // Cache file proportions statically.
  if (!isset($file_proportions)) {
    $file_proportions = array();
  }
  if (isset($file_proportions[$file])) {
    return ($return == 'size') ? $file_proportions[$file][0] : $file_proportions[$file][1];
  }

  else {
    $pad = '';

    // Determine source file's dimensions and proportions.
    $info = ffmpeg_wrapper_file_data($file);
    if ($info) {
      list($orig_x, $orig_y) = explode('x', $info['video']['s']);
      $orig_q = $orig_x / $orig_y;

      // Determine output dimensions and proportions.
      list($dest_x, $dest_y) = explode('x', $size);
      $dest_q = $dest_x / $dest_y;

      // Calculate new output size and padding.
      if ($orig_q > $dest_q) {
        // Width is the determining factor.
        $dest_y_calc = round($dest_x / $orig_q);
        // Make sure height is divisible by 2, otherwise ffmpeg freaks out.
        $dest_y_calc &= ~1;
        $size = $dest_x . 'x' . $dest_y_calc;
        $padding = $dest_y - $dest_y_calc;
        $padoptions = '-padtop %d -padbottom %d';
      }
      elseif ($dest_q > $orig_q) {
        // Height is the determining factor.
        $dest_x_calc = round($dest_y * $orig_q);
        // Make sure width is divisible by 2, otherwise ffmpeg freaks out.
        $dest_x_calc &= ~1;
        $size = $dest_x_calc . 'x' . $dest_y;
        $padding = $dest_x - $dest_x_calc;
        $padoptions = '-padleft %d -padright %d';
      }

      // Calculate padding on each side. Each value has to be a multiple of 2.
      $padding &= ~1;
      $padding1 = floor($padding / 2);
      $padding1 &= ~1;
      $padding2 = $padding - $padding1;
      $pad = sprintf($padoptions, $padding1, $padding2);
    }

    // Save and return the results.
    $file_proportions[$file] = array($size, $pad);
    return ($return == 'size') ? $size : $pad;
  }
}


/**
 * Check to make sure that FFmpeg is in the path.
 *
 * @return
 *   TRUE if FFmpeg can be executed, FALSE otherwise.
 */
function ffmpeg_wrapper_executable() {
  if (! ffmpeg_wrapper_run_command('')) {
    return false;
  }
  return true;
}


/**
 * Display a table of the supported ffmpeg file formats.
 *
 * @return
 *   The themed HTML form.
 */
function ffmpeg_wrapper_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, ffmpeg_wrapper_get_file_formats() );
  return $output;
}


/**
 * Display a table of the ffmpeg encoding and decoding options.
 *
 * @return
 *   The themed HTML form.
 */
function ffmpeg_wrapper_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, ffmpeg_wrapper_get_codecs() );
  return $output;
}


/**
 * Check FFmpeg's output for errors and try to handle them some way.
 *
 * @param $ffmpeg_object
 *   Object containing all the data to check errors against
 *   - shell output and command run.
 * @param boolean $watchdog
 *   If TRUE, log errors to Drupal's watchdog.
 * @return
 *   TRUE if no errors, FALSE if errors.
 *
 **/
function ffmpeg_wrapper_error_check(&$ffmpeg_object, $watchdog = true) {
  $return = true;

  // build the error conditions these are all pulled by hand at this point
  // @NOTE one has to be careful to have a specific match as there are strings
  // in the output from #ffmpeg which containg "error"
  $errors = array(
    '/Segmentation fault .*/i',
    '/Unsupported .*/i',
    // match: bad formats
    '/Unknown format .*/i',
    '/Unable for find a suitable output format for .*/i',
    '/Incorrect frame size .*/i',
    '/Unsupported codec .*/i',
    '/Could not write header .*/i',
    '/already exists. Overwrite/i',
    '/sh: [0-9a-zA-Z\/]*: not found .*/i',
    '/no such file or directory .*/i',
    '/.*does not support that sample rate.*/i',
    // match: Error while opening codec for output stream #0.1 - maybe incorrect parameters such as bit_rate, rate, width or height
    '/Error while opening codec for output stream.*/i',
    // match: I/O error occured
    '/I\/O error occured/i',
  );

  // check for error conditions
  foreach ($errors as $error) {
    preg_match($error, $ffmpeg_object->output, $matches);
    if (count($matches)) {
      $ffmpeg_object->errors[] = print_r($matches[0], true);
      if ($watchdog) {
        $message = 'FFmpeg failed to convert a file. <b>FFmpeg said:</b> !error <br /><b>Command was:</b> ffmpeg !command <br /><b>Output was:</b> <pre>!output</pre>';
        $variables = array('!error' => $matches[0], '!command' => $ffmpeg_object->command, '!output' => $ffmpeg_object->output);
        watchdog('FFmpeg Wrapper', $message, $variables, WATCHDOG_ERROR);
      }
      return false;
    }
  }

  // check to see that a viable file was created
  if (!empty($ffmpeg_object->output_file)) {
    // check to see that the file had data
    if (filesize($ffmpeg_object->output_file) < 10 ) {
      $message = t('FFmpeg created a file, but it does not have any data');
      $ffmpeg_object->errors[] = $message;
      if ($watchdog) {
        watchdog('FFmpeg', $message,  array(), WATCHDOG_ERROR);
      }
      $return = false;
    }
  }

  return $return;
}


/**
 * Create a path to the called vhook library.
 *
 * @param $name
 *   The name of the vhook library.
 * @return
 *   A full path.
 */
function ffmpeg_wrapper_path_to_vhook($name) {
  if ($path = file_exists(variable_get('ffmpeg_wrapper_vhook', '/usr/local/lib/vhook/') . $name)) {
    return $path;
  }
}

/* ************************************************** */
/* handle requests for configurations                 */
/* ************************************************** */

/**
 * Take an output format and return an array of configuration options.
 * This is a hand built list. Will return default options below to preserve
 * form integrity while switching things.
 *
 * @param $output
 *   An output type (eg: flv, avi, mp4, etc).
 * @return
 *   Array of configuration options.
 */
function ffmpeg_wrapper_output_rules($output) {
  // check to see if we have a configuration for this
  $path = drupal_get_path('module', 'ffmpeg_wrapper');
  if (file_exists($path .'/conf/'. $output .'.conf')) {
    require_once($path .'/conf/'. $output .'.conf');
    return $configuration;
  }

  // we don't have a configuration setting, load up the defaults
  // for any thing that we don't have data for. First check
  // and see if we have a cache
  $cache = cache_get('ffmpeg_wrapper_default_output');
  if (is_array($cache->data)) {
    return $cache->data;
  }

  // no cache, build out the default options
  $default['audio'] = array(
    'ab' => ffmpeg_wrapper_output_rates('ab'),
    'ar' => ffmpeg_wrapper_output_rates('ar'),
    'acodec' => ffmpeg_wrapper_return_codecs('audio'),
  );
  $default['video'] = array(
    'fps' => ffmpeg_wrapper_output_rates('fps'),
    'br' =>  ffmpeg_wrapper_output_rates('br'),
    'vcodec' => ffmpeg_wrapper_return_codecs('video'),
  );
  $default['default'] = 'default';
  cache_set('ffmpeg_wrapper_default_output', $default, 'cache', CACHE_TEMPORARY);
  return $default;
}

/**
 * Display the output rules as json.
 *
 * @param $output
 *   An output type (eg: flv, avi, mp4, etc).
 */
function ffmpeg_wrapper_output_display($output) {
  // get the output rules for this
  if ($rules = ffmpeg_wrapper_output_rules($output)) {
    // now build the JSON out
    print(drupal_to_js($rules));
  }
  exit();
}


/**
 * Load the js. This is a wrapper function just so other modules can use this.
 *
 * @param $prefix
 *   The standard prefix to the elements that will be modified.
 * @param $bind_element
 *   The name of the element (minus the prefix) that will be modifed.
 */
function ffmpeg_wrapper_enable_js($prefix = '', $bind_element = '') {
  // because of the way drupal handles form element ids, we have to transform
  // underscores in string to dashes
  $bind_element = str_replace('_', '-', $bind_element);
  $prefix = str_replace('_', '-', $prefix);

  drupal_add_js('
    $(document).ready(function () {
      $(\'#'. $prefix . $bind_element .'\').bind("change", function () {ffmpeg_wrapper_update_options("'. $prefix .'", "'. $bind_element .'"); });
    });',
    'inline');
  drupal_add_js(array('ffmpeg_wrapper' => array(
    'ffmpeg_wrapper_output_url' => url('ffmpeg_wrapper/output/'),
    'default_string' => t('default'),
   )), 'setting');
  drupal_add_js(drupal_get_path('module', 'ffmpeg_wrapper') .'/ffmpeg_wrapper.js');
}


/* ************************************************** */
/* ffmpeg_wrapper forms                               */
/* ************************************************** */

/**
 * Build a generic form for any module to implementm ffmpeg configuration.
 * This will give any module the ajax form configuration updates.
 * Validation and submission need to be handled by the calling module - this
 * only builds the form call this form inside your form function.
 *
 * @param $configuration
 *   An array of configuration data - could be $form_values.
 * @param $prefix
 *   A prefix for the form elelements, needed for javascript activation on
 *   complex forms (eg: media mover).
 * @return array
 *   A Drupal form array.
 */
function ffmpeg_wrapper_configuration_form($configuration = array(), $form_prefix = '' ) {

  // enable the javascript configuration options on the output type to use AJAX
  // to update the allowed values
  ffmpeg_wrapper_enable_js($form_prefix, 'ffmpeg_output_type');

  $form['ffmpeg_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t("FFmpeg video conversion settings"),
    '#collapsed' => false,
  );

  // build the output formats
  $form['ffmpeg_wrapper']['ffmpeg_output_type'] = array(
    '#type' => 'select',
    '#title' => t('Output format'),
    '#options' => ffmpeg_wrapper_output_formats(),
    '#default_value' => $configuration['ffmpeg_output_type'],
    '#description' => t('Select the output format. Note, some formats may require setting audio or video codecs.'),
  );

  // ---------------------------------------------
  // Audio options
  $form['ffmpeg_wrapper']['audio'] = array(
    '#type' => 'fieldset',
    '#title' => t('Audio conversion settings'),
    '#collapsed' => $configuration['ffmpeg_audio_advanced'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['audio']['ffmpeg_audio_advanced'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use advanced settings'),
    '#description' => t('Use the advanced audio encoding options. If this is off, FFmpeg will encode at a rate similar to the source material.'),
    '#default_value' => $configuration['ffmpeg_audio_advanced'],
  );
  $form['ffmpeg_wrapper']['audio']["ffmpeg_audio_ab"] = array(
    '#type' => 'select',
    '#title' => t('Audio bit rate'),
    '#options' => ffmpeg_wrapper_output_rates('ab'),
    '#default_value' => $configuration['ffmpeg_audio_ab'] ? $configuration['ffmpeg_audio_ab'] :  array('64k'),
    '#description' => t("Audio bit rate for conversion file."),
  );
  $form['ffmpeg_wrapper']['audio']["ffmpeg_audio_ar"] = array(
    '#type' => 'select',
    '#title' => t('Audio sample rate'),
    '#options' => ffmpeg_wrapper_output_rates('ar'),
    '#default_value' => $configuration['ffmpeg_audio_ar'] ? $configuration['ffmpeg_audio_ar'] : 44100,
    '#description' => t('Audio sample rate for conversion.'),
  );
  // set the audio codec in use
  $form['ffmpeg_wrapper']['audio']['ffmpeg_audio_acodec'] = array(
    '#type' => 'select',
    '#title' => t('Audio codec'),
    '#options' => ffmpeg_wrapper_return_codecs('audio'),
    '#default_value' => $configuration['ffmpeg_audio_acodec'] ? $configuration['ffmpeg_audio_acodec'] : 0 ,
    '#description' => t('Select the codec for the output format. Please note, you may need to pick an appropriate video codec for the transcoding. WARNING the codec support right now is experimental. Things may not work as expected.'),
  );

  // -------------------------------------------
  // Video options
  $form['ffmpeg_wrapper']['video'] = array(
    '#type' => 'fieldset',
    '#title' => t('Video conversion settings'),
    '#collapsed' => $configuration['ffmpeg_video_advanced'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_advanced'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use advanced settings'),
    '#description' => t('Use the advanced video encoding options. If this is off, FFmpeg will encode flv at 200 kb/s, 128x96, 25fps.'),
    '#default_value' => $configuration['ffmpeg_video_advanced'],
  );
  // video frame size
  $frame_size = ffmpeg_wrapper_frame_sizes();
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_size'] = array(
    '#type' => 'select',
    '#title' => t('Video frame size'),
    '#options' => $frame_size,
    '#default_value' => $configuration['ffmpeg_video_size'],
    '#description' => t('Dimensions of the converted video. Use the <em>Other</em> option to define your custom size.'),
    '#attributes' => array('class' => 'ffmpeg-video-size'),
    '#validate' => array('mm_ffmpeg_config_video_size_validate' => array('ffmpeg_video_size')),
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_size_other'] = array(
    '#type' => 'textfield',
    '#title' => t('Video frame (Other) size'),
    '#default_value' => $configuration['ffmpeg_video_size_other'],
    '#description' => t('Dimensions of the converted video, of the format 600x400.'),
    '#prefix' => '<div class="ffmpeg-video-size-other">',
    '#suffix' => '</div>',
    '#validate' => array('mm_ffmpeg_config_video_size_validate' => array('ffmpeg_video_size_other')),
    '#size' => 12,
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_fps'] = array(
    '#type' => 'select',
    '#title' => t('Video fps rate'),
    '#options' => ffmpeg_wrapper_output_rates('fps'),
    '#default_value' => $configuration['ffmpeg_video_fps'] ? $configuration['ffmpeg_video_fps'] : array(25),
    '#description' => t("Sets the frames per second of the converted video."),
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_br'] = array(
    '#type' => 'select',
    '#title' => t('Video bit rate'),
    '#options' => ffmpeg_wrapper_output_rates('br'),
    '#default_value' => $configuration['ffmpeg_video_br'] ? $configuration['ffmpeg_video_br'] : array('250k'),
    '#description' => t('Target the output video to this bit rate.'),
  );
  $form['ffmpeg_wrapper']['video']['ffmpeg_video_vcodec'] = array(
    '#type' => 'select',
    '#title' => t('Video codec'),
    '#options' => ffmpeg_wrapper_return_codecs('video'),
    '#default_value' => $configuration['ffmpeg_video_vcodec'] ? $configuration['ffmpeg_video_vcodec'] : 0,
    '#description' => t('Select the codec for the output format. Please note, you may need to pick an appropriate audio codec for the transcoding.'),
  );

  $form['ffmpeg_wrapper']['time'] = array(
    '#type' => 'fieldset',
    '#title' => t('Video duration'),
    '#collapsed' => $configuration['ffmpeg_time_advanced'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['time']['ffmpeg_time_advanced'] = array(
    '#type' => 'checkbox',
    '#title' => t('Truncate the output video'),
    '#description' => t('Use this to limit the length of the output video. Useful for making a video teaser'),
    '#default_value' => $configuration['ffmpeg_time_advanced'],
  );
  $times = array(30 => "30 seconds", 60 => "1 minute", 120 => "2 minutes", 300 => "5 minutes");
  $form['ffmpeg_wrapper']['time']["ffmpeg_time"] = array(
    '#type' => 'select',
    '#title' => t('Video length'),
    '#options' => $times,
    '#default_value' => $configuration['ffmpeg_time'],
    '#description' => t("Set the max video length time."),
  );

  // FFmpeg custom command
  $form['ffmpeg_wrapper']['custom'] = array(
    '#type' => 'fieldset',
    '#title' => t('Custom FFmpeg command'),
    '#collapsed' => $configuration['ffmpeg_video_custom'] ? false : true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['custom']["ffmpeg_video_custom"] = array(
    '#type' => 'checkbox',
    '#title' => t('Use custom FFmpeg command'),
    '#description' => t('Use the custom FFmpeg command in the textfield below.'),
    '#default_value' => $configuration['ffmpeg_video_custom'],
  );
  $form['ffmpeg_wrapper']['custom']["ffmpeg_video_custom_command"] = array(
    '#type' => 'textarea',
    '#rows' => 1,
    '#title' => t('Custom FFmpeg command'),
    '#description' => t('You can craft your own FFmpeg command. Please see the FFmpeg documentation for correct syntax. The command will replace <em>%in_file</em> and <em>%out_file</em> with the generated files. Please note, you can not use | or > in your commands.'),
    '#default_value' => $configuration['ffmpeg_video_custom_command'] ? $configuration['ffmpeg_video_custom_command'] : '-i %in_file %out_file',
  );

  // Watermarking options
  // only display if we have access to the watermarking files
  if (ffmpeg_wrapper_path_to_vhook('watermark.so')) {
    $form['ffmpeg_wrapper']['watermark'] = array(
      '#type' => 'fieldset',
      '#title' => t('Video watermark settings'),
      '#collapsed' => $configuration['ffmpeg_video_wm'] ? false : true,
      '#collapsible' => true,
    );
    $form['ffmpeg_wrapper']['watermark']['ffmpeg_video_wm'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use watermark'),
      '#description' => t('Use a file to watermark the converted video.'),
      '#default_value' => $configuration['ffmpeg_video_wm'],
    );
    // @ TODO make this a file upload
    $form['ffmpeg_wrapper']['watermark']['ffmpeg_video_wm_file'] = array(
      '#type' => 'textfield',
      '#title' => t('Path to file'),
      '#description' => t('Absolute path to the watermark file.'),
      '#default_value' => $configuration['ffmpeg_video_wm_file'],
    );
  }

  // file chmod settings, maybe legacy.....
  $form['ffmpeg_wrapper']['file'] = array(
    '#type' => 'fieldset',
    '#title' => t('File settings'),
    '#collapsed' => true,
    '#collapsible' => true,
  );
  $form['ffmpeg_wrapper']['file']["ffmpeg_output_perms"] = array(
    '#type' => 'textfield',
    '#title' => t('Output file permissions'),
    '#description' => t('Set the permissions on the output file. Default is 0644.'),
    '#default_value' => $configuration['ffmpeg_output_perms'] ? $configuration['ffmpeg_output_perms'] : '0644' ,
    '#size' => 4,
  );

  return $form;
}